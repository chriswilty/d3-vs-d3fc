<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>d3 vs d3fc: a maybe biased comparison</title>
    <script src="https://unpkg.com/d3"></script>
    <script src="https://unpkg.com/d3fc"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
        .container {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: stretch;
        }
        .d3, .fc {
            font-family: sans-serif;
            margin: 32px;
            border: 1px solid grey;
            border-radius: 4px;
            padding: 8px;
            max-width: 600px;
            flex: 1 1 auto;
        }
        .d3 { margin-right: 16px; }
        .fc { margin-left: 16px; }
    </style>
</head>
<body>
  <div class="container">
      <div class="d3"></div>
      <div class="fc"></div>
  </div>
  <script type="application/javascript">
      const generator = fc.randomGeometricBrownianMotion().steps(11);
      const dateFormatter = d3.timeFormat('%b');
      const valueFormatter = d3.format('$.0f');
      const data = {
          targets: [{
              name: 'low',
              value: 4.5
          }, {
              name: 'high',
              value: 7.2
          }],
          sales: generator(1).map((d, i) => ({
              month: dateFormatter(new Date(0, i + 1, 0)),
              sales: d + i / 2
          }))
      };
      const barFill = selection => selection
          .style('fill', d => d.sales >= data.targets.find(t => t.name === 'low').value ? '#0c0' : 'inherit');
      const barColour = targets => d => d.sales >= targets.find(t => t.name === 'low').value ? '#0c0' : 'inherit';

      // d3
      const d3Chart = selection => {
          const width = parseInt(selection.style('width'));
          const height = parseInt(selection.style('height'));
          const margin = { top: 30, right: 60, bottom: 50, left: 0 };

          const xScale = d3.scaleBand()
              .domain(d3.range(selection.datum().sales.length))
              .rangeRound([margin.left, width - margin.right])
              .padding(0.2);
          const yScale = d3.scaleLinear()
              .domain([0, d3.max(selection.datum().sales, d => d.sales) * 1.2]).nice()
              .range([height - margin.bottom, margin.top]);

          const xAxis = g => g
              .attr('transform', `translate(0, ${yScale.range()[0]})`)
              .call(d3.axisBottom(xScale).tickFormat(i => selection.datum().sales[i].month).tickSizeOuter(0))
              .call(g => g.select('.domain').attr('stroke-width', '1.5'));
          const yAxis = g => g
              .attr('transform', `translate(${width - margin.right}, 0)`)
              .call(d3.axisRight(yScale).ticks(5, valueFormatter))
              .call(g => g.select('.domain').attr('stroke-width', '1.5'))
              .call(g => g.append('text')
                  .attr('x', margin.right + 5)
                  .attr('y', (height) / 2)
                  .attr('fill', 'currentColor')
                  .attr('text-anchor', 'middle')
                  .attr('transform', `rotate(-90, ${margin.right - 5}, ${height / 2})`)
                  .attr('font-size', '0.75rem')
                  .text('Sales (millions)')
              );

          const svg = selection.append('svg').attr('viewBox', [0, 0, width, height]);
          svg.append('text')
              .attr('x', `${width / 2}`)
              .attr('y', `${margin.top / 2}`)
              .attr('fill', 'currentColor')
              .attr('text-anchor', 'middle')
              .text('2019 Cumulative Sales');
          svg.append('g')
                .attr('fill', '#999')
              .selectAll('rect')
              .data(selection.datum().sales)
              .join('rect')
                .attr('x', (_,i) => xScale(i))
                .attr('y', d => yScale(d.sales))
                .attr('height', d => yScale(0) - yScale(d.sales))
                .attr('width', xScale.bandwidth())
                .attr('fill', barColour(selection.datum().targets));
          svg.append('g').call(xAxis);
          svg.append('g').call(yAxis);
      };
      d3.select('.d3').datum(data).call(d3Chart);
      // end d3

      // d3fc
      const yExtent = fc.extentLinear()
          .include([0])
          .pad([0, 0.2])
          .accessors([d => d.sales]);
      const bar = fc.autoBandwidth(fc.seriesSvgBar())
          .crossValue(d => d.month)
          .mainValue(d => d.sales)
          .align('left')
          .decorate(selection => selection.select('.bar > path').style('fill', barColour(data.targets)));
      const boundLine = fc.annotationSvgLine()
          .value(d => d.value)
          .decorate(selection => {
              selection.enter().style('font-size', '0.75rem');
              selection.enter().select('line').attr('stroke-dasharray', '4');
              selection.enter().select('g.left-handle').append('text').attr('x', 5).attr('y', -5);
              selection.enter().select('g.right-handle').remove();
              // This data-dependent label needs to update on redraw, not just on enter.
              selection.select('g.left-handle text').text(d => d.name + ': ' + d3.format('$.1f')(d.value) + 'M');
          });
      const multiPlot = fc.seriesSvgMulti()
          .series([bar, boundLine])
          .mapping((data, i, series) => series[i] === bar ? data.sales : data.targets);
      const fcChart = fc.chartCartesian(d3.scaleBand(), d3.scaleLinear())
          .chartLabel('2019 Cumulative Sales')
          .xDomain(data.sales.map(d => d.month))
          .xPadding(0.2)
          .yDomain(yExtent(data.sales))
          .yTicks(5, valueFormatter)
          .yLabel('Sales (millions)')
          .yNice()
          .decorate(el => el.select('.y-label').style('font-size', '0.75rem'))
          .svgPlotArea(multiPlot);
      d3.select('.fc').datum(data).call(fcChart);
      // end d3fc
  </script>
</body>
</html>